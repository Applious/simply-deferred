// Generated by CoffeeScript 1.3.1

/*
Simply Deferred - v.1.1.4
(c) 2012 Sudhir Jonathan, contact.me@sudhirjonathan.com, MIT Licensed.
Portions of this code are inspired and borrowed from Underscore.js (http://underscorejs.org/) (MIT License)
*/


(function() {
  var Deferred, PENDING, REJECTED, RESOLVED, after, execute, flatten, has, installInto, isArguments, wrap, _when,
    __slice = [].slice;

  PENDING = "pending";

  RESOLVED = "resolved";

  REJECTED = "rejected";

  has = function(obj, prop) {
    return obj != null ? obj.hasOwnProperty(prop) : void 0;
  };

  isArguments = function(obj) {
    return has(obj, 'length') && has(obj, 'callee');
  };

  flatten = function(array) {
    if (isArguments(array)) {
      return flatten(Array.prototype.slice.call(array));
    }
    if (!Array.isArray(array)) {
      return [array];
    }
    return array.reduce(function(memo, value) {
      if (Array.isArray(value)) {
        return memo.concat(flatten(value));
      }
      memo.push(value);
      return memo;
    }, []);
  };

  after = function(times, func) {
    if (times <= 0) {
      return func();
    }
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  wrap = function(func, wrapper) {
    return function() {
      var args;
      args = [func].concat(Array.prototype.slice.call(arguments, 0));
      return wrapper.apply(this, args);
    };
  };

  execute = function(callbacks, args) {
    var callback, _i, _len, _ref, _results;
    _ref = flatten(callbacks);
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      callback = _ref[_i];
      _results.push(callback.apply(null, args));
    }
    return _results;
  };

  Deferred = function() {
    var alwaysCallbacks, close, closingArguments, doneCallbacks, failCallbacks, state;
    state = PENDING;
    doneCallbacks = [];
    failCallbacks = [];
    alwaysCallbacks = [];
    closingArguments = {};
    this.promise = function(candidate) {
      var pipe, storeCallbacks;
      candidate = candidate || {};
      candidate.state = function() {
        return state;
      };
      storeCallbacks = function(shouldExecuteImmediately, holder) {
        return function() {
          if (state === PENDING) {
            holder.push.apply(holder, flatten(arguments));
          }
          if (shouldExecuteImmediately()) {
            execute(arguments, closingArguments);
          }
          return candidate;
        };
      };
      pipe = function(doneFilter, failFilter) {
        var new_def, new_done, new_fail;
        new_def = new Deferred();
        if (doneFilter != null) {
          new_done = function() {
            var args, returned, _base;
            args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
            returned = doneFilter.apply(null, args);
            if ((returned.done != null) && (returned.fail != null)) {
              return typeof returned.done === "function" ? typeof (_base = returned.done(new_def.resolve)).fail === "function" ? _base.fail(new_def.reject) : void 0 : void 0;
            } else {
              return new_def.resolve(returned);
            }
          };
          candidate.done(new_done);
        }
        if (doneFilter != null) {
          new_fail = function() {
            var args, returned, _base;
            args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
            returned = failFilter.apply(null, args);
            if ((returned.done != null) && (returned.fail != null)) {
              return typeof returned.done === "function" ? typeof (_base = returned.done(new_def.resolve)).fail === "function" ? _base.fail(new_def.reject) : void 0 : void 0;
            } else {
              return new_def.reject(returned);
            }
          };
          candidate.fail(new_fail);
        }
        return new_def.promise();
      };
      candidate.done = storeCallbacks((function() {
        return state === RESOLVED;
      }), doneCallbacks);
      candidate.fail = storeCallbacks((function() {
        return state === REJECTED;
      }), failCallbacks);
      candidate.always = storeCallbacks((function() {
        return state !== PENDING;
      }), alwaysCallbacks);
      candidate.pipe = pipe;
      candidate.then = pipe;
      return candidate;
    };
    this.promise(this);
    close = function(finalState, callbacks) {
      return function() {
        if (state === PENDING) {
          state = finalState;
          closingArguments = arguments;
          execute([callbacks, alwaysCallbacks], closingArguments);
        }
        return this;
      };
    };
    this.resolve = close(RESOLVED, doneCallbacks);
    this.reject = close(REJECTED, failCallbacks);
    return this;
  };

  _when = function() {
    var def, defs, finish, trigger, _i, _len;
    trigger = new Deferred();
    defs = flatten(arguments);
    finish = after(defs.length, trigger.resolve);
    for (_i = 0, _len = defs.length; _i < _len; _i++) {
      def = defs[_i];
      def.done(finish);
    }
    return trigger.promise();
  };

  installInto = function(fw) {
    fw.Deferred = function() {
      return new Deferred();
    };
    fw.ajax = wrap(fw.ajax, function(ajax, options) {
      var createWrapper, def;
      if (options == null) {
        options = {};
      }
      def = new Deferred();
      createWrapper = function(wrapped, finisher) {
        return wrap(wrapped, function() {
          var args, func;
          func = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
          if (func) {
            func.apply(null, args);
          }
          return finisher.apply(null, args);
        });
      };
      options.success = createWrapper(options.success, def.resolve);
      options.error = createWrapper(options.error, def.reject);
      ajax(options);
      return def.promise();
    });
    return fw.when = _when;
  };

  if (typeof exports !== 'undefined') {
    exports.Deferred = function() {
      return new Deferred();
    };
    exports.when = _when;
    exports.installInto = installInto;
  } else {
    this.Deferred = function() {
      return new Deferred();
    };
    this.Deferred.when = _when;
    this.Deferred.installInto = installInto;
  }

}).call(this);
