// Generated by CoffeeScript 1.3.1

/*
Deferred.js - v.0.1.0
(c) 2012 Sudhir Jonathan, contact.me@sudhirjonathan.com
Released under the MIT License.
*/


(function() {
  var Deferred, PENDING, REJECTED, RESOLVED, execute, flatten, pushWhenPending, _;

  _ = (typeof window !== "undefined" && window !== null ? window._ : void 0) || require('underscore');

  PENDING = "pending";

  RESOLVED = "resolved";

  REJECTED = "rejected";

  flatten = _.flatten;

  pushWhenPending = function(state, holder, args) {
    if (state === PENDING) {
      return holder.push.apply(holder, flatten(args));
    }
  };

  execute = function(callbacks, args) {
    var callback, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = callbacks.length; _i < _len; _i++) {
      callback = callbacks[_i];
      _results.push(callback.apply(null, args));
    }
    return _results;
  };

  Deferred = function() {
    var alwaysCallbacks, closingArguments, doneCallbacks, failCallbacks, state, terminate;
    state = PENDING;
    doneCallbacks = [];
    failCallbacks = [];
    alwaysCallbacks = [];
    closingArguments = {};
    this.promise = function(candidate) {
      var conditionallyExecute;
      candidate = candidate || {};
      candidate.state = function() {
        return state;
      };
      conditionallyExecute = function(shouldRun, args) {
        if (shouldRun) {
          return execute(flatten(args), closingArguments);
        }
      };
      candidate.done = function() {
        pushWhenPending(state, doneCallbacks, arguments);
        conditionallyExecute(state === RESOLVED, arguments);
        return candidate;
      };
      candidate.fail = function() {
        pushWhenPending(state, failCallbacks, arguments);
        conditionallyExecute(state === REJECTED, arguments);
        return candidate;
      };
      candidate.always = function() {
        pushWhenPending(state, alwaysCallbacks, arguments);
        conditionallyExecute(state !== PENDING, arguments);
        return candidate;
      };
      return candidate;
    };
    this.promise(this);
    terminate = function(finalState, callbacks, args) {
      if (state === PENDING) {
        state = finalState;
        closingArguments = args;
        execute(callbacks, closingArguments);
        return execute(alwaysCallbacks, closingArguments);
      }
    };
    this.resolve = function() {
      terminate(RESOLVED, doneCallbacks, arguments);
      return this;
    };
    this.reject = function() {
      terminate(REJECTED, failCallbacks, arguments);
      return this;
    };
    return this;
  };

  (typeof exports !== "undefined" && exports !== null ? exports : window).Deferred = function() {
    return new Deferred();
  };

}).call(this);
